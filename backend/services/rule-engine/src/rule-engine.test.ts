import { describe, it, expect, beforeEach } from 'vitest';
import { RuleEngine } from './rule-engine';
import { Condition } from './types';

describe('RuleEngine', () => {
  let engine: RuleEngine;

  beforeEach(() => {
    engine = new RuleEngine();
  });

  describe('addRule', () => {
    it('should add a rule successfully', () => {
      const ruleId = engine.addRule({
        name: 'Test Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'temperature', operator: 'gt', value: 25 },
        actions: [{ type: 'notification', message: 'Too hot!' }],
      });

      expect(ruleId).toBeDefined();
      expect(engine.getRule(ruleId)).toBeDefined();
    });

    it('should reject rule with too many actions', () => {
      const actions = Array(25).fill({ type: 'notification', message: 'test' });

      expect(() => {
        engine.addRule({
          name: 'Invalid Rule',
          enabled: true,
          autoGenerated: false,
          priority: 5,
          condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
          actions,
        });
      }).toThrow('Too many actions');
    });

    it('should reject rule with no actions', () => {
      expect(() => {
        engine.addRule({
          name: 'Invalid Rule',
          enabled: true,
          autoGenerated: false,
          priority: 5,
          condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
          actions: [],
        });
      }).toThrow('Rule has no actions');
    });
  });

  describe('evaluateRules', () => {
    it('should match simple condition', async () => {
      engine.addRule({
        name: 'Temperature Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'temperature', operator: 'gt', value: 25 },
        actions: [{ type: 'notification', message: 'Hot!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { temperature: 30 },
      });

      expect(matches).toHaveLength(1);
      expect(matches[0].name).toBe('Temperature Rule');
    });

    it('should handle AND conditions', async () => {
      const condition: Condition = {
        type: 'and',
        conditions: [
          { type: 'simple', field: 'temperature', operator: 'gt', value: 25 },
          { type: 'simple', field: 'humidity', operator: 'lt', value: 60 },
        ],
      };

      engine.addRule({
        name: 'Complex Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition,
        actions: [{ type: 'notification', message: 'Conditions met!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { temperature: 30, humidity: 50 },
      });

      expect(matches).toHaveLength(1);
    });

    it('should handle OR conditions', async () => {
      const condition: Condition = {
        type: 'or',
        conditions: [
          { type: 'simple', field: 'motion', operator: 'eq', value: true },
          { type: 'simple', field: 'door', operator: 'eq', value: 'open' },
        ],
      };

      engine.addRule({
        name: 'Security Rule',
        enabled: true,
        autoGenerated: false,
        priority: 10,
        condition,
        actions: [{ type: 'notification', message: 'Motion or door!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { motion: true, door: 'closed' },
      });

      expect(matches).toHaveLength(1);
    });

    it('should skip disabled rules', async () => {
      engine.addRule({
        name: 'Disabled Rule',
        enabled: false,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'Test' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { test: 1 },
      });

      expect(matches).toHaveLength(0);
    });

    it('should sort rules by priority', async () => {
      engine.addRule({
        name: 'Low Priority',
        enabled: true,
        autoGenerated: false,
        priority: 1,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'Low' }],
      });

      engine.addRule({
        name: 'High Priority',
        enabled: true,
        autoGenerated: false,
        priority: 10,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'High' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { test: 1 },
      });

      expect(matches[0].name).toBe('High Priority');
      expect(matches[1].name).toBe('Low Priority');
    });
  });

  describe('executeRule', () => {
    it('should execute rule successfully', async () => {
      const ruleId = engine.addRule({
        name: 'Test Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'Test' }],
      });

      await engine.executeRule(ruleId, {
        timestamp: new Date(),
        data: {},
      });

      const rule = engine.getRule(ruleId);
      expect(rule?.executionCount).toBe(1);
      expect(rule?.lastExecuted).toBeDefined();
    });

    it('should respect cooldown period', async () => {
      const ruleId = engine.addRule({
        name: 'Cooldown Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        cooldownMs: 5000,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'Test' }],
      });

      await engine.executeRule(ruleId, { timestamp: new Date(), data: {} });

      await expect(
        engine.executeRule(ruleId, { timestamp: new Date(), data: {} })
      ).rejects.toThrow('cannot be executed due to rate limiting');
    });

    it('should respect max activations per hour', async () => {
      const ruleId = engine.addRule({
        name: 'Rate Limited Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        cooldownMs: 0,
        maxActivationsPerHour: 2,
        condition: { type: 'simple', field: 'test', operator: 'eq', value: 1 },
        actions: [{ type: 'notification', message: 'Test' }],
      });

      await engine.executeRule(ruleId, { timestamp: new Date(), data: {} });
      await engine.executeRule(ruleId, { timestamp: new Date(), data: {} });

      await expect(
        engine.executeRule(ruleId, { timestamp: new Date(), data: {} })
      ).rejects.toThrow('cannot be executed due to rate limiting');
    });
  });

  describe('condition operators', () => {
    it('should evaluate eq operator', async () => {
      const ruleId = engine.addRule({
        name: 'Equality Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'status', operator: 'eq', value: 'on' },
        actions: [{ type: 'notification', message: 'On!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { status: 'on' },
      });

      expect(matches).toHaveLength(1);
    });

    it('should evaluate ne operator', async () => {
      engine.addRule({
        name: 'Not Equal Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'status', operator: 'ne', value: 'off' },
        actions: [{ type: 'notification', message: 'Not off!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { status: 'on' },
      });

      expect(matches).toHaveLength(1);
    });

    it('should evaluate contains operator', async () => {
      engine.addRule({
        name: 'Contains Rule',
        enabled: true,
        autoGenerated: false,
        priority: 5,
        condition: { type: 'simple', field: 'message', operator: 'contains', value: 'hello' },
        actions: [{ type: 'notification', message: 'Found!' }],
      });

      const matches = await engine.evaluateRules({
        timestamp: new Date(),
        data: { message: 'hello world' },
      });

      expect(matches).toHaveLength(1);
    });
  });
});
